/* ---------------------------------------------------------------------
 * Numenta Platform for Intelligent Computing (NuPIC)
 * Copyright (C) 2014-2016, Numenta, Inc.  Unless you have an agreement
 * with Numenta, Inc., for a separate license for this software code, the
 * following terms and conditions apply:
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU Affero Public License for more details.
 *
 * You should have received a copy of the GNU Affero Public License
 * along with this program.  If not, see http://www.gnu.org/licenses.
 *
 * http://numenta.org/licenses/
 * ---------------------------------------------------------------------
 */
package org.numenta.nupic.util;

import java.util.List;
import java.util.function.Function;

import chaschev.lang.Pair;

/**
 * <p>
 * Allegory to the Python itertools.groupby. Objects of this class
 * take a list of inputs and a function to produce keys. The iterator
 * or foreach loop generates grouped return values based on the key
 * generated by the supplied function.<br> 类似于Python的itertools.groupby。此类的对象获取一个输入列表和一个生成键值的函数。迭代器或foreach循环根据提供的函数生成的键生成分组返回值
 * For instance:<br>
 * <pre>
 * Given the list:
 * List<Integer> l = Arrays.asList(new Integer[] { 2, 4, 4, 5 });
 * and the function:
 * Function<Integer, Integer> lambda = x -> x * 3;
 * 
 * A GroupBy can be compose as such:
 * GroupBy<Integer, Integer> grouper = GroupBy.of(l, lambda);
 * 
 * ...then iterated over as such:
 * for(Pair<Integer, Integer> p : grouper) {
 *     System.out.println("Pair key: " + p.getKey() + ", pair value: " + p.getValue());
 * }
 * 
 * Outputs:
 * 
 * Pair key: 2, pair value: 6
 * Pair key: 4, pair value: 12
 * Pair key: 4, pair value: 12
 * Pair key: 5, pair value: 15
 * </p>
 * <p>
 * Notes: Read up on groupby here:
 *        https://docs.python.org/dev/library/itertools.html#itertools.groupby
 *        
 * </p>
 * @author cogmission
 *
 * @param <T>
 * @param <R>
 */
public class GroupBy<T, R> implements Generator<Pair<T, R>>, PeekableIterator<Pair<T, R>> {

    /** serial version */
    private static final long serialVersionUID = 1L;
    
    private List<T> iter;//相当于是输入值的列表
    private Function<T, R> fn;//相当于是对每个输入值执行操作的函数
    private Generator<Integer> range;//范围函数
    private Pair<T, R> next;//输入值和输入值执行操作的函数构成一个Pair
    
    
    /**
     * Constructs a new {@code GroupBy}
     * 
     * @param l     the {@link List} containing the items used as input to the
     *              key generating function.     l参数是包含用作key生成函数的输入条目的列表
     * @param fn    the {@link Function} to be used to generate the keys which describe
     *              the like contents of each grouping. fn是用来生成key值的函数，key用来描述每一个分组相似的内容
     */
    public GroupBy(List<T> l, Function<T, R> fn) {
        this.iter = l;//初始化类的输入值
        this.fn = fn;//初始化对每个输入值执行操作的函数
        this.range = IntGenerator.of(0, iter.size());//获取输入值列表大小的Int数组
        
        if(range.hasNext()) {
            T t = iter.get(range.next());//获取每个输入值
            next = new Pair<T, R>(t, fn.apply(t));//把输入值和输入值操作函数计算的结果构成一个Pair,但是这里next存储的是第一个输入值和输入值操作函数计算的结果形成的Pair
        }
    }
    
    /**
     * {@inheritDoc},获取当前输入值和输入值操作函数计算的结果形成的Pair
     */
    @Override
    public Pair<T, R> peek() {
        return next;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean hasNext() {
        return next != null;
    }

    /**
     * {@inheritDoc}获取下一个输入值和输入值操作函数计算结果形成的Pair
     */
    @Override
    public Pair<T, R> next() {
        T t = range.hasNext() ? iter.get(range.next()) : null;//获取
        Pair<T, R> ret = next;//命令ret为当前的值
        next = t != null ? new Pair<T, R>(t, fn.apply(t)) : null;//把next换为下一个值
        return ret;
    }
    
    /**
     * Returns a new {@code GroupBy} composed from the specified list 
     * and key-generating {@link Function}
     * 返回一个新的GroupBy由指定的list和key-生成函数组成
     * @param l     the {@link List} containing the items used as input to the
     *              key generating function.     
     * @param fn    the {@link Function} to be used to generate the keys which describe
     *              the like contents of each grouping.
     * @return
     */
    public static <T, R> GroupBy<T, R> of(List<T> l, Function<T, R> fn) {//<T,R>用来申明此方法为泛型方法，GroupBy<T,R>才是此方法的返回值类型，of才是函数名称
        return new GroupBy<T, R>(l, fn);
    }
 }
